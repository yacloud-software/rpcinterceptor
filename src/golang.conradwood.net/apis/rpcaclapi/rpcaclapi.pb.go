// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/rpcaclapi/rpcaclapi.proto
// DO NOT EDIT!

/*
Package rpcaclapi is a generated protocol buffer package.

It is generated from these files:
	protos/golang.conradwood.net/apis/rpcaclapi/rpcaclapi.proto

It has these top-level messages:
	Service
	Method
	ServiceList
	GetMethodsRequest
	MethodList
	FullMethodList
	FullMethod
	LogEntryRequest
	LogEntry
	LogEntryList
	MethodIDAndGroupID
	LogSearchRequest
	ErrorSearchRequest
	ErrorEntryList
	ErrorEntry
	Call
	CallList
	ServiceNameRequest
	ServiceIDResponse
	DBRule
	DBRuleMatch
	DBRuleService
	DBRuleGroup
	Rule
	ServiceRules
	ServiceID
	ServiceIDList
	GroupServiceRequest
	ServiceByUserIDRequest
	ServiceByIDRequest
*/
package rpcaclapi

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import auth "golang.conradwood.net/apis/auth"
import _ "golang.conradwood.net/apis/common"
import rpcinterceptor "golang.conradwood.net/apis/rpcinterceptor"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// rule matches on wether service or user or both or neither exists
type RuleMatch int32

const (
	RuleMatch_INVALID          RuleMatch = 0
	RuleMatch_NEITHER          RuleMatch = 1
	RuleMatch_SERVICE_ONLY     RuleMatch = 2
	RuleMatch_USER_ONLY        RuleMatch = 3
	RuleMatch_SERVICE_AND_USER RuleMatch = 4
)

var RuleMatch_name = map[int32]string{
	0: "INVALID",
	1: "NEITHER",
	2: "SERVICE_ONLY",
	3: "USER_ONLY",
	4: "SERVICE_AND_USER",
}
var RuleMatch_value = map[string]int32{
	"INVALID":          0,
	"NEITHER":          1,
	"SERVICE_ONLY":     2,
	"USER_ONLY":        3,
	"SERVICE_AND_USER": 4,
}

func (x RuleMatch) String() string {
	return proto.EnumName(RuleMatch_name, int32(x))
}
func (RuleMatch) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Service struct {
	ID     uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name   string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	UserID string `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Service) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Service) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Service) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

type Method struct {
	ID        uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	ServiceID uint64 `protobuf:"varint,3,opt,name=ServiceID" json:"ServiceID,omitempty"`
}

func (m *Method) Reset()                    { *m = Method{} }
func (m *Method) String() string            { return proto.CompactTextString(m) }
func (*Method) ProtoMessage()               {}
func (*Method) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Method) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Method) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Method) GetServiceID() uint64 {
	if m != nil {
		return m.ServiceID
	}
	return 0
}

type ServiceList struct {
	Services []*Service `protobuf:"bytes,1,rep,name=Services" json:"Services,omitempty"`
}

func (m *ServiceList) Reset()                    { *m = ServiceList{} }
func (m *ServiceList) String() string            { return proto.CompactTextString(m) }
func (*ServiceList) ProtoMessage()               {}
func (*ServiceList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ServiceList) GetServices() []*Service {
	if m != nil {
		return m.Services
	}
	return nil
}

type GetMethodsRequest struct {
	ServiceID uint64 `protobuf:"varint,1,opt,name=ServiceID" json:"ServiceID,omitempty"`
}

func (m *GetMethodsRequest) Reset()                    { *m = GetMethodsRequest{} }
func (m *GetMethodsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMethodsRequest) ProtoMessage()               {}
func (*GetMethodsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *GetMethodsRequest) GetServiceID() uint64 {
	if m != nil {
		return m.ServiceID
	}
	return 0
}

type MethodList struct {
	Methods []*Method `protobuf:"bytes,1,rep,name=Methods" json:"Methods,omitempty"`
}

func (m *MethodList) Reset()                    { *m = MethodList{} }
func (m *MethodList) String() string            { return proto.CompactTextString(m) }
func (*MethodList) ProtoMessage()               {}
func (*MethodList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *MethodList) GetMethods() []*Method {
	if m != nil {
		return m.Methods
	}
	return nil
}

type FullMethodList struct {
	Methods []*FullMethod `protobuf:"bytes,1,rep,name=Methods" json:"Methods,omitempty"`
}

func (m *FullMethodList) Reset()                    { *m = FullMethodList{} }
func (m *FullMethodList) String() string            { return proto.CompactTextString(m) }
func (*FullMethodList) ProtoMessage()               {}
func (*FullMethodList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *FullMethodList) GetMethods() []*FullMethod {
	if m != nil {
		return m.Methods
	}
	return nil
}

type FullMethod struct {
	ID      uint64   `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name    string   `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	Service *Service `protobuf:"bytes,3,opt,name=Service" json:"Service,omitempty"`
}

func (m *FullMethod) Reset()                    { *m = FullMethod{} }
func (m *FullMethod) String() string            { return proto.CompactTextString(m) }
func (*FullMethod) ProtoMessage()               {}
func (*FullMethod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FullMethod) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *FullMethod) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FullMethod) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

type LogEntryRequest struct {
	MaxEntries uint64 `protobuf:"varint,1,opt,name=MaxEntries" json:"MaxEntries,omitempty"`
}

func (m *LogEntryRequest) Reset()                    { *m = LogEntryRequest{} }
func (m *LogEntryRequest) String() string            { return proto.CompactTextString(m) }
func (*LogEntryRequest) ProtoMessage()               {}
func (*LogEntryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *LogEntryRequest) GetMaxEntries() uint64 {
	if m != nil {
		return m.MaxEntries
	}
	return 0
}

type LogEntry struct {
	Timestamp uint64                               `protobuf:"varint,1,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Service   *Service                             `protobuf:"bytes,2,opt,name=Service" json:"Service,omitempty"`
	Method    *Method                              `protobuf:"bytes,3,opt,name=Method" json:"Method,omitempty"`
	Response  *rpcinterceptor.InterceptRPCResponse `protobuf:"bytes,4,opt,name=Response" json:"Response,omitempty"`
}

func (m *LogEntry) Reset()                    { *m = LogEntry{} }
func (m *LogEntry) String() string            { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()               {}
func (*LogEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *LogEntry) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *LogEntry) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *LogEntry) GetMethod() *Method {
	if m != nil {
		return m.Method
	}
	return nil
}

func (m *LogEntry) GetResponse() *rpcinterceptor.InterceptRPCResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type LogEntryList struct {
	Entries []*LogEntry `protobuf:"bytes,1,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *LogEntryList) Reset()                    { *m = LogEntryList{} }
func (m *LogEntryList) String() string            { return proto.CompactTextString(m) }
func (*LogEntryList) ProtoMessage()               {}
func (*LogEntryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *LogEntryList) GetEntries() []*LogEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type MethodIDAndGroupID struct {
	MethodID uint64 `protobuf:"varint,1,opt,name=MethodID" json:"MethodID,omitempty"`
	GroupID  string `protobuf:"bytes,2,opt,name=GroupID" json:"GroupID,omitempty"`
}

func (m *MethodIDAndGroupID) Reset()                    { *m = MethodIDAndGroupID{} }
func (m *MethodIDAndGroupID) String() string            { return proto.CompactTextString(m) }
func (*MethodIDAndGroupID) ProtoMessage()               {}
func (*MethodIDAndGroupID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *MethodIDAndGroupID) GetMethodID() uint64 {
	if m != nil {
		return m.MethodID
	}
	return 0
}

func (m *MethodIDAndGroupID) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

type LogSearchRequest struct {
	// only include entries which these user(s) made (empty list=all)
	UserIDs []string `protobuf:"bytes,1,rep,name=UserIDs" json:"UserIDs,omitempty"`
	// only include entries which users in these groups made (empty list=all)
	GroupIDs []string `protobuf:"bytes,2,rep,name=GroupIDs" json:"GroupIDs,omitempty"`
	// automatically include entries which do not match the SearchRequest but have the same requestid as one that matched
	FullRequests bool `protobuf:"varint,3,opt,name=FullRequests" json:"FullRequests,omitempty"`
	// unix epoch starttime (only include entries younger than this). 0 = all
	StartTime uint32 `protobuf:"varint,4,opt,name=StartTime" json:"StartTime,omitempty"`
	// unix epoch endtime (only include entries older than this). 0 = all
	EndTime uint32 `protobuf:"varint,5,opt,name=EndTime" json:"EndTime,omitempty"`
	// only include entries where the caller service is in this list (empty list=all)
	CallerServiceIDs []uint64 `protobuf:"varint,6,rep,packed,name=CallerServiceIDs" json:"CallerServiceIDs,omitempty"`
	// only include entries where the called service is in this list (empty list=all)
	CalledServiceIDs []uint64 `protobuf:"varint,7,rep,packed,name=CalledServiceIDs" json:"CalledServiceIDs,omitempty"`
	// only include entries where the caller method is in this list (empty list=all)
	CallerMethodIDs []uint64 `protobuf:"varint,8,rep,packed,name=CallerMethodIDs" json:"CallerMethodIDs,omitempty"`
	// only include entries where the called method is in this list (empty list=all)
	CalledMethodIDs []uint64 `protobuf:"varint,9,rep,packed,name=CalledMethodIDs" json:"CalledMethodIDs,omitempty"`
	// limit searchlogs to these request IDs
	RequestIDs []string `protobuf:"bytes,10,rep,name=RequestIDs" json:"RequestIDs,omitempty"`
}

func (m *LogSearchRequest) Reset()                    { *m = LogSearchRequest{} }
func (m *LogSearchRequest) String() string            { return proto.CompactTextString(m) }
func (*LogSearchRequest) ProtoMessage()               {}
func (*LogSearchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *LogSearchRequest) GetUserIDs() []string {
	if m != nil {
		return m.UserIDs
	}
	return nil
}

func (m *LogSearchRequest) GetGroupIDs() []string {
	if m != nil {
		return m.GroupIDs
	}
	return nil
}

func (m *LogSearchRequest) GetFullRequests() bool {
	if m != nil {
		return m.FullRequests
	}
	return false
}

func (m *LogSearchRequest) GetStartTime() uint32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *LogSearchRequest) GetEndTime() uint32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *LogSearchRequest) GetCallerServiceIDs() []uint64 {
	if m != nil {
		return m.CallerServiceIDs
	}
	return nil
}

func (m *LogSearchRequest) GetCalledServiceIDs() []uint64 {
	if m != nil {
		return m.CalledServiceIDs
	}
	return nil
}

func (m *LogSearchRequest) GetCallerMethodIDs() []uint64 {
	if m != nil {
		return m.CallerMethodIDs
	}
	return nil
}

func (m *LogSearchRequest) GetCalledMethodIDs() []uint64 {
	if m != nil {
		return m.CalledMethodIDs
	}
	return nil
}

func (m *LogSearchRequest) GetRequestIDs() []string {
	if m != nil {
		return m.RequestIDs
	}
	return nil
}

type ErrorSearchRequest struct {
	// only include entries which these user(s) made (empty list=all)
	UserIDs []string `protobuf:"bytes,1,rep,name=UserIDs" json:"UserIDs,omitempty"`
	// only include entries which users in these groups made (empty list=all)
	GroupIDs []string `protobuf:"bytes,2,rep,name=GroupIDs" json:"GroupIDs,omitempty"`
	// automatically include entries which do not match the SearchRequest but have the same requestid as one that matched
	FullRequests bool `protobuf:"varint,3,opt,name=FullRequests" json:"FullRequests,omitempty"`
	// unix epoch starttime (only include entries younger than this). 0 = all
	StartTime uint32 `protobuf:"varint,4,opt,name=StartTime" json:"StartTime,omitempty"`
	// unix epoch endtime (only include entries older than this). 0 = all
	EndTime uint32 `protobuf:"varint,5,opt,name=EndTime" json:"EndTime,omitempty"`
	// only include entries where the caller service is in this list (empty list=all)
	CallerServiceIDs []uint64 `protobuf:"varint,6,rep,packed,name=CallerServiceIDs" json:"CallerServiceIDs,omitempty"`
	// only include entries where the called service is in this list (empty list=all)
	CalledServiceIDs []uint64 `protobuf:"varint,7,rep,packed,name=CalledServiceIDs" json:"CalledServiceIDs,omitempty"`
	// only include entries where the caller method is in this list (empty list=all)
	CallerMethodIDs []uint64 `protobuf:"varint,8,rep,packed,name=CallerMethodIDs" json:"CallerMethodIDs,omitempty"`
	// only include entries where the called method is in this list (empty list=all)
	CalledMethodIDs []uint64 `protobuf:"varint,9,rep,packed,name=CalledMethodIDs" json:"CalledMethodIDs,omitempty"`
	// limit searchlogs to these request IDs
	RequestIDs []string `protobuf:"bytes,10,rep,name=RequestIDs" json:"RequestIDs,omitempty"`
	// exclude those userids
	ExcludeUserIDs []string `protobuf:"bytes,11,rep,name=ExcludeUserIDs" json:"ExcludeUserIDs,omitempty"`
}

func (m *ErrorSearchRequest) Reset()                    { *m = ErrorSearchRequest{} }
func (m *ErrorSearchRequest) String() string            { return proto.CompactTextString(m) }
func (*ErrorSearchRequest) ProtoMessage()               {}
func (*ErrorSearchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ErrorSearchRequest) GetUserIDs() []string {
	if m != nil {
		return m.UserIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetGroupIDs() []string {
	if m != nil {
		return m.GroupIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetFullRequests() bool {
	if m != nil {
		return m.FullRequests
	}
	return false
}

func (m *ErrorSearchRequest) GetStartTime() uint32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ErrorSearchRequest) GetEndTime() uint32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *ErrorSearchRequest) GetCallerServiceIDs() []uint64 {
	if m != nil {
		return m.CallerServiceIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetCalledServiceIDs() []uint64 {
	if m != nil {
		return m.CalledServiceIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetCallerMethodIDs() []uint64 {
	if m != nil {
		return m.CallerMethodIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetCalledMethodIDs() []uint64 {
	if m != nil {
		return m.CalledMethodIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetRequestIDs() []string {
	if m != nil {
		return m.RequestIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetExcludeUserIDs() []string {
	if m != nil {
		return m.ExcludeUserIDs
	}
	return nil
}

type ErrorEntryList struct {
	Entries []*ErrorEntry `protobuf:"bytes,1,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *ErrorEntryList) Reset()                    { *m = ErrorEntryList{} }
func (m *ErrorEntryList) String() string            { return proto.CompactTextString(m) }
func (*ErrorEntryList) ProtoMessage()               {}
func (*ErrorEntryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ErrorEntryList) GetEntries() []*ErrorEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type ErrorEntry struct {
	Timestamp      uint64     `protobuf:"varint,1,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Service        *Service   `protobuf:"bytes,2,opt,name=Service" json:"Service,omitempty"`
	Method         *Method    `protobuf:"bytes,3,opt,name=Method" json:"Method,omitempty"`
	RequestID      string     `protobuf:"bytes,4,opt,name=RequestID" json:"RequestID,omitempty"`
	CallerUser     *auth.User `protobuf:"bytes,5,opt,name=CallerUser" json:"CallerUser,omitempty"`
	ErrorCode      uint32     `protobuf:"varint,6,opt,name=ErrorCode" json:"ErrorCode,omitempty"`
	DisplayMessage string     `protobuf:"bytes,7,opt,name=DisplayMessage" json:"DisplayMessage,omitempty"`
	LogMessage     string     `protobuf:"bytes,8,opt,name=LogMessage" json:"LogMessage,omitempty"`
}

func (m *ErrorEntry) Reset()                    { *m = ErrorEntry{} }
func (m *ErrorEntry) String() string            { return proto.CompactTextString(m) }
func (*ErrorEntry) ProtoMessage()               {}
func (*ErrorEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ErrorEntry) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ErrorEntry) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *ErrorEntry) GetMethod() *Method {
	if m != nil {
		return m.Method
	}
	return nil
}

func (m *ErrorEntry) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *ErrorEntry) GetCallerUser() *auth.User {
	if m != nil {
		return m.CallerUser
	}
	return nil
}

func (m *ErrorEntry) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ErrorEntry) GetDisplayMessage() string {
	if m != nil {
		return m.DisplayMessage
	}
	return ""
}

func (m *ErrorEntry) GetLogMessage() string {
	if m != nil {
		return m.LogMessage
	}
	return ""
}

type Call struct {
	CalledMethod   *FullMethod `protobuf:"bytes,1,opt,name=CalledMethod" json:"CalledMethod,omitempty"`
	CallingService *auth.User  `protobuf:"bytes,2,opt,name=CallingService" json:"CallingService,omitempty"`
	CallingUser    *auth.User  `protobuf:"bytes,3,opt,name=CallingUser" json:"CallingUser,omitempty"`
}

func (m *Call) Reset()                    { *m = Call{} }
func (m *Call) String() string            { return proto.CompactTextString(m) }
func (*Call) ProtoMessage()               {}
func (*Call) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Call) GetCalledMethod() *FullMethod {
	if m != nil {
		return m.CalledMethod
	}
	return nil
}

func (m *Call) GetCallingService() *auth.User {
	if m != nil {
		return m.CallingService
	}
	return nil
}

func (m *Call) GetCallingUser() *auth.User {
	if m != nil {
		return m.CallingUser
	}
	return nil
}

type CallList struct {
	Calls []*Call `protobuf:"bytes,1,rep,name=Calls" json:"Calls,omitempty"`
}

func (m *CallList) Reset()                    { *m = CallList{} }
func (m *CallList) String() string            { return proto.CompactTextString(m) }
func (*CallList) ProtoMessage()               {}
func (*CallList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *CallList) GetCalls() []*Call {
	if m != nil {
		return m.Calls
	}
	return nil
}

type ServiceNameRequest struct {
	Name string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
}

func (m *ServiceNameRequest) Reset()                    { *m = ServiceNameRequest{} }
func (m *ServiceNameRequest) String() string            { return proto.CompactTextString(m) }
func (*ServiceNameRequest) ProtoMessage()               {}
func (*ServiceNameRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ServiceNameRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ServiceIDResponse struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *ServiceIDResponse) Reset()                    { *m = ServiceIDResponse{} }
func (m *ServiceIDResponse) String() string            { return proto.CompactTextString(m) }
func (*ServiceIDResponse) ProtoMessage()               {}
func (*ServiceIDResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ServiceIDResponse) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type DBRule struct {
	ID            uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ServiceID     uint64 `protobuf:"varint,2,opt,name=ServiceID" json:"ServiceID,omitempty"`
	ResultOnMatch bool   `protobuf:"varint,3,opt,name=ResultOnMatch" json:"ResultOnMatch,omitempty"`
}

func (m *DBRule) Reset()                    { *m = DBRule{} }
func (m *DBRule) String() string            { return proto.CompactTextString(m) }
func (*DBRule) ProtoMessage()               {}
func (*DBRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *DBRule) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBRule) GetServiceID() uint64 {
	if m != nil {
		return m.ServiceID
	}
	return 0
}

func (m *DBRule) GetResultOnMatch() bool {
	if m != nil {
		return m.ResultOnMatch
	}
	return false
}

type DBRuleMatch struct {
	ID        uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RuleID    uint64 `protobuf:"varint,2,opt,name=RuleID" json:"RuleID,omitempty"`
	RuleMatch uint32 `protobuf:"varint,3,opt,name=RuleMatch" json:"RuleMatch,omitempty"`
}

func (m *DBRuleMatch) Reset()                    { *m = DBRuleMatch{} }
func (m *DBRuleMatch) String() string            { return proto.CompactTextString(m) }
func (*DBRuleMatch) ProtoMessage()               {}
func (*DBRuleMatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *DBRuleMatch) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBRuleMatch) GetRuleID() uint64 {
	if m != nil {
		return m.RuleID
	}
	return 0
}

func (m *DBRuleMatch) GetRuleMatch() uint32 {
	if m != nil {
		return m.RuleMatch
	}
	return 0
}

type DBRuleService struct {
	ID            uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RuleID        uint64 `protobuf:"varint,2,opt,name=RuleID" json:"RuleID,omitempty"`
	ServiceUserID string `protobuf:"bytes,3,opt,name=ServiceUserID" json:"ServiceUserID,omitempty"`
}

func (m *DBRuleService) Reset()                    { *m = DBRuleService{} }
func (m *DBRuleService) String() string            { return proto.CompactTextString(m) }
func (*DBRuleService) ProtoMessage()               {}
func (*DBRuleService) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *DBRuleService) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBRuleService) GetRuleID() uint64 {
	if m != nil {
		return m.RuleID
	}
	return 0
}

func (m *DBRuleService) GetServiceUserID() string {
	if m != nil {
		return m.ServiceUserID
	}
	return ""
}

type DBRuleGroup struct {
	ID      uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RuleID  uint64 `protobuf:"varint,2,opt,name=RuleID" json:"RuleID,omitempty"`
	GroupID string `protobuf:"bytes,3,opt,name=GroupID" json:"GroupID,omitempty"`
}

func (m *DBRuleGroup) Reset()                    { *m = DBRuleGroup{} }
func (m *DBRuleGroup) String() string            { return proto.CompactTextString(m) }
func (*DBRuleGroup) ProtoMessage()               {}
func (*DBRuleGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *DBRuleGroup) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBRuleGroup) GetRuleID() uint64 {
	if m != nil {
		return m.RuleID
	}
	return 0
}

func (m *DBRuleGroup) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

//
// the checks on inbound request are done like so:
// 1. check if presence of calleruser and callerservice match any of the "RuleMatch" - if not: skip
// 2. if user exists and is not in group AND group is non-empty: skip
// 3. if service exists and is not in list AND list is non-empty: skip
// 4. Apply "grant"
type Rule struct {
	ID            uint64      `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Match         []RuleMatch `protobuf:"varint,2,rep,packed,name=Match,enum=rpcaclapi.RuleMatch" json:"Match,omitempty"`
	FromServiceID []string    `protobuf:"bytes,3,rep,name=FromServiceID" json:"FromServiceID,omitempty"`
	GroupID       []string    `protobuf:"bytes,4,rep,name=GroupID" json:"GroupID,omitempty"`
	Grant         bool        `protobuf:"varint,5,opt,name=Grant" json:"Grant,omitempty"`
}

func (m *Rule) Reset()                    { *m = Rule{} }
func (m *Rule) String() string            { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()               {}
func (*Rule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *Rule) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Rule) GetMatch() []RuleMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *Rule) GetFromServiceID() []string {
	if m != nil {
		return m.FromServiceID
	}
	return nil
}

func (m *Rule) GetGroupID() []string {
	if m != nil {
		return m.GroupID
	}
	return nil
}

func (m *Rule) GetGrant() bool {
	if m != nil {
		return m.Grant
	}
	return false
}

// this defines how to decide wether or not to grant access to a service
type ServiceRules struct {
	ServiceID uint64  `protobuf:"varint,1,opt,name=ServiceID" json:"ServiceID,omitempty"`
	Rules     []*Rule `protobuf:"bytes,2,rep,name=Rules" json:"Rules,omitempty"`
}

func (m *ServiceRules) Reset()                    { *m = ServiceRules{} }
func (m *ServiceRules) String() string            { return proto.CompactTextString(m) }
func (*ServiceRules) ProtoMessage()               {}
func (*ServiceRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *ServiceRules) GetServiceID() uint64 {
	if m != nil {
		return m.ServiceID
	}
	return 0
}

func (m *ServiceRules) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type ServiceID struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *ServiceID) Reset()                    { *m = ServiceID{} }
func (m *ServiceID) String() string            { return proto.CompactTextString(m) }
func (*ServiceID) ProtoMessage()               {}
func (*ServiceID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *ServiceID) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type ServiceIDList struct {
	ID []uint64 `protobuf:"varint,1,rep,packed,name=ID" json:"ID,omitempty"`
}

func (m *ServiceIDList) Reset()                    { *m = ServiceIDList{} }
func (m *ServiceIDList) String() string            { return proto.CompactTextString(m) }
func (*ServiceIDList) ProtoMessage()               {}
func (*ServiceIDList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *ServiceIDList) GetID() []uint64 {
	if m != nil {
		return m.ID
	}
	return nil
}

type GroupServiceRequest struct {
	ServiceName string `protobuf:"bytes,1,opt,name=ServiceName" json:"ServiceName,omitempty"`
	ServiceID   uint64 `protobuf:"varint,2,opt,name=ServiceID" json:"ServiceID,omitempty"`
	GroupID     string `protobuf:"bytes,3,opt,name=GroupID" json:"GroupID,omitempty"`
}

func (m *GroupServiceRequest) Reset()                    { *m = GroupServiceRequest{} }
func (m *GroupServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*GroupServiceRequest) ProtoMessage()               {}
func (*GroupServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *GroupServiceRequest) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *GroupServiceRequest) GetServiceID() uint64 {
	if m != nil {
		return m.ServiceID
	}
	return 0
}

func (m *GroupServiceRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

type ServiceByUserIDRequest struct {
	UserID string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
}

func (m *ServiceByUserIDRequest) Reset()                    { *m = ServiceByUserIDRequest{} }
func (m *ServiceByUserIDRequest) String() string            { return proto.CompactTextString(m) }
func (*ServiceByUserIDRequest) ProtoMessage()               {}
func (*ServiceByUserIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *ServiceByUserIDRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

type ServiceByIDRequest struct {
	ID string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *ServiceByIDRequest) Reset()                    { *m = ServiceByIDRequest{} }
func (m *ServiceByIDRequest) String() string            { return proto.CompactTextString(m) }
func (*ServiceByIDRequest) ProtoMessage()               {}
func (*ServiceByIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *ServiceByIDRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func init() {
	proto.RegisterType((*Service)(nil), "rpcaclapi.Service")
	proto.RegisterType((*Method)(nil), "rpcaclapi.Method")
	proto.RegisterType((*ServiceList)(nil), "rpcaclapi.ServiceList")
	proto.RegisterType((*GetMethodsRequest)(nil), "rpcaclapi.GetMethodsRequest")
	proto.RegisterType((*MethodList)(nil), "rpcaclapi.MethodList")
	proto.RegisterType((*FullMethodList)(nil), "rpcaclapi.FullMethodList")
	proto.RegisterType((*FullMethod)(nil), "rpcaclapi.FullMethod")
	proto.RegisterType((*LogEntryRequest)(nil), "rpcaclapi.LogEntryRequest")
	proto.RegisterType((*LogEntry)(nil), "rpcaclapi.LogEntry")
	proto.RegisterType((*LogEntryList)(nil), "rpcaclapi.LogEntryList")
	proto.RegisterType((*MethodIDAndGroupID)(nil), "rpcaclapi.MethodIDAndGroupID")
	proto.RegisterType((*LogSearchRequest)(nil), "rpcaclapi.LogSearchRequest")
	proto.RegisterType((*ErrorSearchRequest)(nil), "rpcaclapi.ErrorSearchRequest")
	proto.RegisterType((*ErrorEntryList)(nil), "rpcaclapi.ErrorEntryList")
	proto.RegisterType((*ErrorEntry)(nil), "rpcaclapi.ErrorEntry")
	proto.RegisterType((*Call)(nil), "rpcaclapi.Call")
	proto.RegisterType((*CallList)(nil), "rpcaclapi.CallList")
	proto.RegisterType((*ServiceNameRequest)(nil), "rpcaclapi.ServiceNameRequest")
	proto.RegisterType((*ServiceIDResponse)(nil), "rpcaclapi.ServiceIDResponse")
	proto.RegisterType((*DBRule)(nil), "rpcaclapi.DBRule")
	proto.RegisterType((*DBRuleMatch)(nil), "rpcaclapi.DBRuleMatch")
	proto.RegisterType((*DBRuleService)(nil), "rpcaclapi.DBRuleService")
	proto.RegisterType((*DBRuleGroup)(nil), "rpcaclapi.DBRuleGroup")
	proto.RegisterType((*Rule)(nil), "rpcaclapi.Rule")
	proto.RegisterType((*ServiceRules)(nil), "rpcaclapi.ServiceRules")
	proto.RegisterType((*ServiceID)(nil), "rpcaclapi.ServiceID")
	proto.RegisterType((*ServiceIDList)(nil), "rpcaclapi.ServiceIDList")
	proto.RegisterType((*GroupServiceRequest)(nil), "rpcaclapi.GroupServiceRequest")
	proto.RegisterType((*ServiceByUserIDRequest)(nil), "rpcaclapi.ServiceByUserIDRequest")
	proto.RegisterType((*ServiceByIDRequest)(nil), "rpcaclapi.ServiceByIDRequest")
	proto.RegisterEnum("rpcaclapi.RuleMatch", RuleMatch_name, RuleMatch_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RPCACLService service

type RPCACLServiceClient interface {
	// given a serviceid for a service, this will return the rpcinterceptor service
	GetServiceByID(ctx context.Context, in *ServiceByIDRequest, opts ...grpc.CallOption) (*Service, error)
	// given a userid for a service, this will return the rpcinterceptor service
	// rpc GetServiceByUserID(ServiceByUserIDRequest) returns (Service);  // get ALL services currently known
	// (known means: a method of this service has requested authentication at least once.)
	// rpc GetServices(common.Void) returns (ServiceList);
	// get all methods currently known for a given service
	// (known means: the method has requested authentication at least once.)
	// rpc GetMethods(GetMethodsRequest) returns (MethodList);
	// get all groups known to the auth service.
	// essentially queries & caches the auth service
	// OBSOLETE
	// rpc GetUserGroups(common.Void) returns (auth.GroupList);
	// add user to group
	// OBSOLETE
	// rpc AddUserToGroup(auth.AddToGroupRequest) returns (common.Void);
	// remove user from a group
	// OBSOLETE
	// rpc RemoveUserFromGroup(auth.RemoveFromGroupRequest) returns (common.Void);
	// get all users for a group
	// OBSOLETE
	// rpc ListUsersInGroup(auth.ListGroupRequest) returns (auth.UserListResponse);
	// get all groups associated (have access to) a given method
	// OBSOLETE
	// rpc GetGroupsForMethod(Method) returns (auth.GroupList);
	// add a group to a Method (grant access to an rpc for a given group)
	// returns the list of groups for this method PRIOR to the update
	// OBSOLETE
	// rpc AddGroupToMethod(MethodIDAndGroupID) returns (auth.GroupList);
	// remove a group from a method (revoke access to an rpc for a given group)
	// returns the list of groups for this method PRIOR to the update
	// OBSOLETE
	// rpc RemoveGroupFromMethod(MethodIDAndGroupID) returns (auth.GroupList);
	// return list of methods a group as access to
	// OBSOLETE
	// rpc GetMethodsForGroups(auth.Group) returns (FullMethodList);
	// gets the most recent logentries limited by some count
	// OBSOLETE
	// rpc GetMostRecentLogs(LogEntryRequest) returns (LogEntryList);
	// gets the most recent logentries for the calling user
	// OBSOLETE
	// rpc GetMyMostRecentLogs(LogEntryRequest) returns (LogEntryList);
	// sophisticated(ish) search for logs
	// OBSOLETE
	// rpc SearchLogs(LogSearchRequest) returns (LogEntryList);
	// UNDOCUMENTED CALL, USE WITH CARE
	// OBSOLETE
	// rpc ListCalls(common.Void) returns (CallList);
	// sophisticated(ish) search for errors which occured in the system
	// OBSOLETE
	// rpc SearchErrors(ErrorSearchRequest) returns (ErrorEntryList);
	// ServiceNametoID (privileged)
	ServiceNameToID(ctx context.Context, in *ServiceNameRequest, opts ...grpc.CallOption) (*ServiceIDResponse, error)
}

type rPCACLServiceClient struct {
	cc *grpc.ClientConn
}

func NewRPCACLServiceClient(cc *grpc.ClientConn) RPCACLServiceClient {
	return &rPCACLServiceClient{cc}
}

func (c *rPCACLServiceClient) GetServiceByID(ctx context.Context, in *ServiceByIDRequest, opts ...grpc.CallOption) (*Service, error) {
	out := new(Service)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/GetServiceByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) ServiceNameToID(ctx context.Context, in *ServiceNameRequest, opts ...grpc.CallOption) (*ServiceIDResponse, error) {
	out := new(ServiceIDResponse)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/ServiceNameToID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RPCACLService service

type RPCACLServiceServer interface {
	// given a serviceid for a service, this will return the rpcinterceptor service
	GetServiceByID(context.Context, *ServiceByIDRequest) (*Service, error)
	// given a userid for a service, this will return the rpcinterceptor service
	// rpc GetServiceByUserID(ServiceByUserIDRequest) returns (Service);  // get ALL services currently known
	// (known means: a method of this service has requested authentication at least once.)
	// rpc GetServices(common.Void) returns (ServiceList);
	// get all methods currently known for a given service
	// (known means: the method has requested authentication at least once.)
	// rpc GetMethods(GetMethodsRequest) returns (MethodList);
	// get all groups known to the auth service.
	// essentially queries & caches the auth service
	// OBSOLETE
	// rpc GetUserGroups(common.Void) returns (auth.GroupList);
	// add user to group
	// OBSOLETE
	// rpc AddUserToGroup(auth.AddToGroupRequest) returns (common.Void);
	// remove user from a group
	// OBSOLETE
	// rpc RemoveUserFromGroup(auth.RemoveFromGroupRequest) returns (common.Void);
	// get all users for a group
	// OBSOLETE
	// rpc ListUsersInGroup(auth.ListGroupRequest) returns (auth.UserListResponse);
	// get all groups associated (have access to) a given method
	// OBSOLETE
	// rpc GetGroupsForMethod(Method) returns (auth.GroupList);
	// add a group to a Method (grant access to an rpc for a given group)
	// returns the list of groups for this method PRIOR to the update
	// OBSOLETE
	// rpc AddGroupToMethod(MethodIDAndGroupID) returns (auth.GroupList);
	// remove a group from a method (revoke access to an rpc for a given group)
	// returns the list of groups for this method PRIOR to the update
	// OBSOLETE
	// rpc RemoveGroupFromMethod(MethodIDAndGroupID) returns (auth.GroupList);
	// return list of methods a group as access to
	// OBSOLETE
	// rpc GetMethodsForGroups(auth.Group) returns (FullMethodList);
	// gets the most recent logentries limited by some count
	// OBSOLETE
	// rpc GetMostRecentLogs(LogEntryRequest) returns (LogEntryList);
	// gets the most recent logentries for the calling user
	// OBSOLETE
	// rpc GetMyMostRecentLogs(LogEntryRequest) returns (LogEntryList);
	// sophisticated(ish) search for logs
	// OBSOLETE
	// rpc SearchLogs(LogSearchRequest) returns (LogEntryList);
	// UNDOCUMENTED CALL, USE WITH CARE
	// OBSOLETE
	// rpc ListCalls(common.Void) returns (CallList);
	// sophisticated(ish) search for errors which occured in the system
	// OBSOLETE
	// rpc SearchErrors(ErrorSearchRequest) returns (ErrorEntryList);
	// ServiceNametoID (privileged)
	ServiceNameToID(context.Context, *ServiceNameRequest) (*ServiceIDResponse, error)
}

func RegisterRPCACLServiceServer(s *grpc.Server, srv RPCACLServiceServer) {
	s.RegisterService(&_RPCACLService_serviceDesc, srv)
}

func _RPCACLService_GetServiceByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).GetServiceByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/GetServiceByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).GetServiceByID(ctx, req.(*ServiceByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_ServiceNameToID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).ServiceNameToID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/ServiceNameToID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).ServiceNameToID(ctx, req.(*ServiceNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCACLService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpcaclapi.RPCACLService",
	HandlerType: (*RPCACLServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetServiceByID",
			Handler:    _RPCACLService_GetServiceByID_Handler,
		},
		{
			MethodName: "ServiceNameToID",
			Handler:    _RPCACLService_ServiceNameToID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/golang.conradwood.net/apis/rpcaclapi/rpcaclapi.proto",
}

func init() {
	proto.RegisterFile("protos/golang.conradwood.net/apis/rpcaclapi/rpcaclapi.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1176 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xec, 0x57, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0x66, 0x6d, 0xc7, 0x3f, 0xc7, 0xb1, 0xe3, 0x4c, 0x43, 0xb4, 0x0a, 0x01, 0xa2, 0x21, 0x54,
	0x26, 0x14, 0x87, 0x84, 0xab, 0x0a, 0x15, 0x91, 0xd8, 0x6e, 0xd8, 0xca, 0x71, 0xaa, 0x71, 0x5a,
	0x09, 0xa9, 0x50, 0x2d, 0xf6, 0xc8, 0xb1, 0xb4, 0xde, 0x31, 0xbb, 0x6b, 0x68, 0xde, 0x04, 0x71,
	0x0b, 0x6f, 0xc0, 0x23, 0xf0, 0x42, 0x3c, 0x02, 0x9a, 0xbf, 0x9d, 0xd9, 0x75, 0x92, 0xe6, 0x0a,
	0x6e, 0x7a, 0x93, 0xf8, 0x7c, 0xf3, 0x9d, 0x9f, 0x39, 0xe7, 0xcc, 0x99, 0x59, 0xf8, 0x7a, 0x11,
	0xb1, 0x84, 0xc5, 0x87, 0x53, 0x16, 0xf8, 0xe1, 0xb4, 0x33, 0x66, 0x61, 0xe4, 0x4f, 0x7e, 0x65,
	0x6c, 0xd2, 0x09, 0x69, 0x72, 0xe8, 0x2f, 0x66, 0xf1, 0x61, 0xb4, 0x18, 0xfb, 0xe3, 0xc0, 0x5f,
	0xcc, 0xcc, 0xaf, 0x8e, 0xd0, 0x42, 0xb5, 0x14, 0xd8, 0x39, 0xb8, 0xc3, 0x80, 0xbf, 0x4c, 0xae,
	0xc4, 0x1f, 0xa9, 0xb6, 0xd3, 0xb9, 0x83, 0x3b, 0x66, 0xf3, 0x39, 0x0b, 0xd5, 0x3f, 0xc5, 0xff,
	0xe6, 0xee, 0xe0, 0x66, 0x61, 0x42, 0xa3, 0x31, 0x5d, 0x24, 0x2c, 0xca, 0x89, 0x52, 0x1f, 0xf7,
	0xa1, 0x32, 0xa2, 0xd1, 0x2f, 0xb3, 0x31, 0x45, 0x4d, 0x28, 0x78, 0x3d, 0xd7, 0xd9, 0x73, 0xda,
	0x25, 0x52, 0xf0, 0x7a, 0x08, 0x41, 0x69, 0xe8, 0xcf, 0xa9, 0x5b, 0xd8, 0x73, 0xda, 0x35, 0x22,
	0x7e, 0xa3, 0x6d, 0x28, 0xbf, 0x88, 0x69, 0xe4, 0xf5, 0xdc, 0xa2, 0x40, 0x95, 0x84, 0x9f, 0x41,
	0xf9, 0x9c, 0x26, 0x57, 0x6c, 0x72, 0x2f, 0x2b, 0xbb, 0x50, 0x53, 0x4e, 0x95, 0xa1, 0x12, 0x31,
	0x00, 0x7e, 0x02, 0x75, 0x25, 0x0c, 0x66, 0x71, 0x82, 0x3a, 0x50, 0x55, 0x62, 0xec, 0x3a, 0x7b,
	0xc5, 0x76, 0xfd, 0x18, 0x75, 0x4c, 0xb2, 0xd5, 0x12, 0x49, 0x39, 0xf8, 0x08, 0x36, 0xcf, 0x68,
	0x22, 0xa3, 0x89, 0x09, 0xfd, 0x79, 0x49, 0xe3, 0x24, 0xeb, 0xd1, 0xc9, 0x7b, 0x7c, 0x0c, 0x20,
	0xf9, 0xc2, 0xe1, 0xe7, 0x50, 0x51, 0xda, 0xca, 0xdf, 0xa6, 0xe5, 0x4f, 0xae, 0x10, 0xcd, 0xc0,
	0x27, 0xd0, 0x7c, 0xba, 0x0c, 0x02, 0x4b, 0xfd, 0x30, 0xaf, 0xfe, 0xbe, 0xa5, 0x6e, 0xb8, 0xc6,
	0xc4, 0x8f, 0x00, 0x06, 0xbe, 0x57, 0xfe, 0x1e, 0xa5, 0x45, 0x13, 0xd9, 0xbb, 0x39, 0x23, 0x9a,
	0x82, 0x8f, 0x60, 0x63, 0xc0, 0xa6, 0xfd, 0x30, 0x89, 0xae, 0x75, 0x3a, 0x3e, 0x02, 0x38, 0xf7,
	0xdf, 0x70, 0x68, 0x26, 0xb2, 0xca, 0x9d, 0x59, 0x08, 0xfe, 0xdb, 0x81, 0xaa, 0xd6, 0xe1, 0xb9,
	0xbb, 0x9c, 0xcd, 0x69, 0x9c, 0xf8, 0xf3, 0x85, 0xce, 0x5d, 0x0a, 0xd8, 0xb1, 0x14, 0xde, 0x1a,
	0x0b, 0xfa, 0x4c, 0xf7, 0x89, 0x0a, 0xfc, 0x86, 0xd4, 0xea, 0x46, 0xfa, 0x16, 0xaa, 0x84, 0xc6,
	0x0b, 0x16, 0xc6, 0xd4, 0x2d, 0x09, 0xf2, 0x7e, 0x27, 0xd7, 0xc2, 0x9e, 0xfe, 0x4d, 0x9e, 0x77,
	0x35, 0x97, 0xa4, 0x5a, 0xf8, 0x09, 0xac, 0xeb, 0x4d, 0x88, 0xca, 0x7c, 0x01, 0x15, 0xb3, 0x65,
	0x5e, 0x99, 0x07, 0x96, 0xf7, 0x34, 0x45, 0x9a, 0x83, 0x9f, 0x01, 0x92, 0xa1, 0x78, 0xbd, 0x93,
	0x70, 0x72, 0x16, 0xb1, 0xe5, 0xc2, 0xeb, 0xa1, 0x1d, 0xa8, 0x6a, 0x54, 0x25, 0x23, 0x95, 0x91,
	0x0b, 0x15, 0x45, 0x53, 0xe5, 0xd2, 0x22, 0xfe, 0xa7, 0x00, 0xad, 0x01, 0x9b, 0x8e, 0xa8, 0x1f,
	0x8d, 0xaf, 0x74, 0x15, 0x5c, 0xa8, 0xc8, 0xe3, 0x23, 0xe3, 0xa9, 0x11, 0x2d, 0x72, 0x27, 0x4a,
	0x33, 0x76, 0x0b, 0x62, 0x29, 0x95, 0x11, 0x86, 0x75, 0xde, 0x2e, 0xca, 0x48, 0x2c, 0x12, 0x59,
	0x25, 0x19, 0x4c, 0xb4, 0x7b, 0xe2, 0x47, 0x09, 0x2f, 0x93, 0x48, 0x5e, 0x83, 0x18, 0x80, 0xfb,
	0xed, 0x87, 0x13, 0xb1, 0xb6, 0x26, 0xd6, 0xb4, 0x88, 0x0e, 0xa0, 0xd5, 0xf5, 0x83, 0x80, 0x46,
	0xe9, 0xd9, 0x88, 0xdd, 0xf2, 0x5e, 0xb1, 0x5d, 0x22, 0x2b, 0x78, 0xca, 0x9d, 0x58, 0xdc, 0x8a,
	0xc5, 0xb5, 0x70, 0xd4, 0x86, 0x0d, 0xa9, 0xaf, 0x53, 0x15, 0xbb, 0x55, 0x41, 0xcd, 0xc3, 0x29,
	0x73, 0x62, 0x98, 0x35, 0x8b, 0x69, 0x60, 0xde, 0xc3, 0x6a, 0xbf, 0x9c, 0x04, 0x22, 0x4b, 0x16,
	0x82, 0x7f, 0x2f, 0x02, 0xea, 0x47, 0x11, 0x8b, 0xde, 0x25, 0xfd, 0x3f, 0x4b, 0x3a, 0x7a, 0x08,
	0xcd, 0xfe, 0x9b, 0x71, 0xb0, 0x9c, 0x50, 0x9d, 0xe4, 0xba, 0xe0, 0xe4, 0x50, 0x3e, 0x36, 0x45,
	0x6d, 0xcc, 0xe1, 0x3c, 0xcc, 0x1f, 0x4e, 0x7b, 0x6c, 0x1a, 0xae, 0x39, 0x9e, 0x7f, 0x15, 0x00,
	0x0c, 0xfe, 0x7f, 0x4d, 0xa9, 0x5d, 0xa8, 0xa5, 0xdb, 0x17, 0x45, 0xaf, 0x11, 0x03, 0xa0, 0x03,
	0x00, 0x99, 0x6b, 0xbe, 0x6f, 0x51, 0xf7, 0xfa, 0x31, 0x74, 0xc4, 0x75, 0xcf, 0x11, 0x62, 0xad,
	0x72, 0x4b, 0x62, 0x3b, 0x5d, 0x36, 0xa1, 0x6e, 0x59, 0xb6, 0x4f, 0x0a, 0xf0, 0xc4, 0xf6, 0x66,
	0xf1, 0x22, 0xf0, 0xaf, 0xcf, 0x69, 0x1c, 0xfb, 0x53, 0xea, 0x56, 0x84, 0xb3, 0x1c, 0xca, 0x0b,
	0x34, 0x60, 0x53, 0xcd, 0xa9, 0x0a, 0x8e, 0x85, 0xe0, 0x3f, 0x1c, 0x28, 0x71, 0xa7, 0xe8, 0x31,
	0xac, 0xdb, 0xc5, 0x15, 0x29, 0xbb, 0xf5, 0xae, 0xca, 0x50, 0xd1, 0x31, 0x34, 0xb9, 0x3c, 0x0b,
	0xa7, 0xd9, 0x9c, 0xda, 0x3b, 0xcb, 0x31, 0xd0, 0x23, 0xa8, 0x2b, 0x44, 0xa4, 0xa2, 0xb8, 0xa2,
	0x60, 0x2f, 0xe3, 0x23, 0xa8, 0x72, 0x51, 0x34, 0xc6, 0xa7, 0xb0, 0xc6, 0x7f, 0xeb, 0xb6, 0xd8,
	0xb0, 0x22, 0xe4, 0x38, 0x91, 0xab, 0xb8, 0x0d, 0x48, 0xf9, 0xe2, 0x57, 0xa4, 0x3e, 0xed, 0xfa,
	0xf6, 0x74, 0xcc, 0xed, 0x89, 0x3f, 0x81, 0xcd, 0xf4, 0x94, 0xe8, 0xbb, 0x22, 0x7f, 0xed, 0xe2,
	0x57, 0x50, 0xee, 0x9d, 0x92, 0x65, 0xb0, 0xfa, 0x2c, 0xca, 0x3c, 0x25, 0x0a, 0xb9, 0xa7, 0x04,
	0xda, 0x87, 0x06, 0xa1, 0xf1, 0x32, 0x48, 0x2e, 0xc2, 0x73, 0x3f, 0x19, 0x5f, 0xa9, 0x49, 0x91,
	0x05, 0xf1, 0x08, 0xea, 0xd2, 0xba, 0x10, 0x57, 0x5c, 0x6c, 0x43, 0x99, 0x2f, 0xa6, 0xf6, 0x95,
	0x24, 0x9a, 0x4d, 0x2b, 0x09, 0xc3, 0x0d, 0x62, 0x00, 0xfc, 0x03, 0x34, 0xa4, 0xd1, 0xdb, 0x1e,
	0x74, 0xb7, 0x99, 0xdd, 0x87, 0x86, 0x52, 0xc9, 0xbc, 0xed, 0xb2, 0x20, 0xbe, 0xd0, 0x31, 0x8b,
	0xa1, 0x78, 0x6f, 0xe3, 0xd6, 0x9d, 0x58, 0xcc, 0xde, 0x89, 0xbf, 0x39, 0x50, 0xba, 0x31, 0xc3,
	0x07, 0xb0, 0x26, 0xb7, 0xc8, 0xa7, 0x70, 0xf3, 0x78, 0xcb, 0xaa, 0x78, 0xba, 0x5b, 0x22, 0x29,
	0x3c, 0xf6, 0xa7, 0x11, 0x9b, 0xdb, 0xcf, 0x49, 0x3e, 0x6f, 0xb2, 0xa0, 0x1d, 0x44, 0x49, 0x0e,
	0x7d, 0x7d, 0x9d, 0x6f, 0xc1, 0xda, 0x59, 0xe4, 0x87, 0x89, 0x38, 0x9c, 0x55, 0x22, 0x05, 0x3c,
	0x82, 0x75, 0x3d, 0x14, 0x96, 0x01, 0x8d, 0xef, 0x7e, 0x3e, 0xf2, 0x0e, 0x15, 0x34, 0x11, 0x6f,
	0xb6, 0x43, 0x39, 0x4e, 0xe4, 0x2a, 0xfe, 0xc0, 0x32, 0xb2, 0xd2, 0x6f, 0x1f, 0xa7, 0x35, 0xf0,
	0x7a, 0xa2, 0xed, 0x35, 0xa1, 0xa8, 0x08, 0x0c, 0x1e, 0x88, 0x98, 0x75, 0x5c, 0xaa, 0xc1, 0xf7,
	0xd2, 0xc7, 0xb2, 0xd5, 0xe7, 0x36, 0xf4, 0x96, 0x7e, 0xbd, 0xbd, 0x3c, 0x5f, 0xc2, 0xb6, 0xa2,
	0x9d, 0x5e, 0xcb, 0x16, 0xd0, 0x3e, 0xcd, 0x47, 0x80, 0x93, 0xf9, 0x08, 0xd8, 0x4f, 0x8f, 0xe0,
	0xe9, 0xb5, 0x61, 0x9b, 0x9d, 0xd6, 0xf8, 0x46, 0x0e, 0x5e, 0x59, 0x4d, 0x8c, 0xea, 0x50, 0xf1,
	0x86, 0x2f, 0x4f, 0x06, 0x5e, 0xaf, 0xf5, 0x1e, 0x17, 0x86, 0x7d, 0xef, 0xf2, 0xbb, 0x3e, 0x69,
	0x39, 0xa8, 0x05, 0xeb, 0xa3, 0x3e, 0x79, 0xe9, 0x75, 0xfb, 0xaf, 0x2f, 0x86, 0x83, 0xef, 0x5b,
	0x05, 0xd4, 0x80, 0xda, 0x8b, 0x51, 0x9f, 0x48, 0xb1, 0x88, 0xb6, 0xa0, 0xa5, 0x09, 0x27, 0xc3,
	0xde, 0x6b, 0xbe, 0xd4, 0x2a, 0x1d, 0xff, 0xe9, 0x40, 0x83, 0x3c, 0xef, 0x9e, 0x74, 0x07, 0xfa,
	0x14, 0x74, 0xa1, 0x79, 0x46, 0x13, 0x2b, 0x30, 0xf4, 0xe1, 0xea, 0xec, 0xb7, 0x02, 0xde, 0xb9,
	0xe1, 0x6a, 0x40, 0x43, 0xd8, 0xb0, 0x72, 0x7a, 0xc9, 0x6e, 0xb6, 0x62, 0x4d, 0x9e, 0x9d, 0xdd,
	0xd5, 0x65, 0x33, 0x6e, 0x4e, 0x1f, 0xc2, 0x7e, 0x48, 0x13, 0xfb, 0xab, 0x4d, 0x7d, 0xc7, 0xf1,
	0x0f, 0x37, 0xa3, 0xf9, 0x53, 0x59, 0x7c, 0xa5, 0x7d, 0xf5, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x46, 0xff, 0x27, 0x8b, 0x8b, 0x0e, 0x00, 0x00,
}
