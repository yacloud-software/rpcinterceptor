// Code generated by protoc-gen-go.
// source: golang.singingcat.net/apis/scmodcomms/scmodcomms.proto
// DO NOT EDIT!

/*
Package scmodcomms is a generated protocol buffer package.

It is generated from these files:
	golang.singingcat.net/apis/scmodcomms/scmodcomms.proto

It has these top-level messages:
	Response
	ProcessRequest
	ProcessResponse
	ModuleStats
	Flow
	ModuleStatus
	FlowID
	Call
	CallResponse
	ComResponse
	SpecialRoute
*/
package scmodcomms

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import singingcat "golang.singingcat.net/apis/singingcat"
import scweb "golang.singingcat.net/apis/scweb"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Response struct {
	Command *singingcat.Command `protobuf:"bytes,1,opt,name=Command" json:"Command,omitempty"`
	Sender  *scweb.Module       `protobuf:"bytes,2,opt,name=Sender" json:"Sender,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Response) GetCommand() *singingcat.Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *Response) GetSender() *scweb.Module {
	if m != nil {
		return m.Sender
	}
	return nil
}

type ProcessRequest struct {
	Command *singingcat.Command `protobuf:"bytes,1,opt,name=Command" json:"Command,omitempty"`
}

func (m *ProcessRequest) Reset()                    { *m = ProcessRequest{} }
func (m *ProcessRequest) String() string            { return proto.CompactTextString(m) }
func (*ProcessRequest) ProtoMessage()               {}
func (*ProcessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ProcessRequest) GetCommand() *singingcat.Command {
	if m != nil {
		return m.Command
	}
	return nil
}

type ProcessResponse struct {
	StopProcessing bool `protobuf:"varint,1,opt,name=StopProcessing" json:"StopProcessing,omitempty"`
}

func (m *ProcessResponse) Reset()                    { *m = ProcessResponse{} }
func (m *ProcessResponse) String() string            { return proto.CompactTextString(m) }
func (*ProcessResponse) ProtoMessage()               {}
func (*ProcessResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ProcessResponse) GetStopProcessing() bool {
	if m != nil {
		return m.StopProcessing
	}
	return false
}

// in database
type ModuleStats struct {
	ID              uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	LastComReceived uint32 `protobuf:"varint,2,opt,name=LastComReceived" json:"LastComReceived,omitempty"`
}

func (m *ModuleStats) Reset()                    { *m = ModuleStats{} }
func (m *ModuleStats) String() string            { return proto.CompactTextString(m) }
func (*ModuleStats) ProtoMessage()               {}
func (*ModuleStats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ModuleStats) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ModuleStats) GetLastComReceived() uint32 {
	if m != nil {
		return m.LastComReceived
	}
	return 0
}

type Flow struct {
	Module                  *singingcat.ModuleRef `protobuf:"bytes,1,opt,name=Module" json:"Module,omitempty"`
	InternalID              uint32                `protobuf:"varint,2,opt,name=InternalID" json:"InternalID,omitempty"`
	Created                 uint32                `protobuf:"varint,3,opt,name=Created" json:"Created,omitempty"`
	TimeSincePos            uint32                `protobuf:"varint,4,opt,name=TimeSincePos" json:"TimeSincePos,omitempty"`
	IsStarted               bool                  `protobuf:"varint,5,opt,name=IsStarted" json:"IsStarted,omitempty"`
	Name                    string                `protobuf:"bytes,6,opt,name=Name" json:"Name,omitempty"`
	CurrentPosition         uint32                `protobuf:"varint,7,opt,name=CurrentPosition" json:"CurrentPosition,omitempty"`
	CurrentPositionFailures uint32                `protobuf:"varint,8,opt,name=CurrentPositionFailures" json:"CurrentPositionFailures,omitempty"`
	Next                    *Flow                 `protobuf:"bytes,9,opt,name=Next" json:"Next,omitempty"`
}

func (m *Flow) Reset()                    { *m = Flow{} }
func (m *Flow) String() string            { return proto.CompactTextString(m) }
func (*Flow) ProtoMessage()               {}
func (*Flow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Flow) GetModule() *singingcat.ModuleRef {
	if m != nil {
		return m.Module
	}
	return nil
}

func (m *Flow) GetInternalID() uint32 {
	if m != nil {
		return m.InternalID
	}
	return 0
}

func (m *Flow) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Flow) GetTimeSincePos() uint32 {
	if m != nil {
		return m.TimeSincePos
	}
	return 0
}

func (m *Flow) GetIsStarted() bool {
	if m != nil {
		return m.IsStarted
	}
	return false
}

func (m *Flow) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Flow) GetCurrentPosition() uint32 {
	if m != nil {
		return m.CurrentPosition
	}
	return 0
}

func (m *Flow) GetCurrentPositionFailures() uint32 {
	if m != nil {
		return m.CurrentPositionFailures
	}
	return 0
}

func (m *Flow) GetNext() *Flow {
	if m != nil {
		return m.Next
	}
	return nil
}

type ModuleStatus struct {
	Flows []*Flow `protobuf:"bytes,1,rep,name=Flows" json:"Flows,omitempty"`
}

func (m *ModuleStatus) Reset()                    { *m = ModuleStatus{} }
func (m *ModuleStatus) String() string            { return proto.CompactTextString(m) }
func (*ModuleStatus) ProtoMessage()               {}
func (*ModuleStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ModuleStatus) GetFlows() []*Flow {
	if m != nil {
		return m.Flows
	}
	return nil
}

type FlowID struct {
	InternalID uint32 `protobuf:"varint,1,opt,name=InternalID" json:"InternalID,omitempty"`
}

func (m *FlowID) Reset()                    { *m = FlowID{} }
func (m *FlowID) String() string            { return proto.CompactTextString(m) }
func (*FlowID) ProtoMessage()               {}
func (*FlowID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FlowID) GetInternalID() uint32 {
	if m != nil {
		return m.InternalID
	}
	return 0
}

type Call struct {
	Module       *singingcat.ModuleRef `protobuf:"bytes,1,opt,name=Module" json:"Module,omitempty"`
	Type         singingcat.ComType    `protobuf:"varint,2,opt,name=Type,enum=singingcat.ComType" json:"Type,omitempty"`
	Args         [][]byte              `protobuf:"bytes,3,rep,name=Args,proto3" json:"Args,omitempty"`
	RetrySeconds uint32                `protobuf:"varint,4,opt,name=RetrySeconds" json:"RetrySeconds,omitempty"`
}

func (m *Call) Reset()                    { *m = Call{} }
func (m *Call) String() string            { return proto.CompactTextString(m) }
func (*Call) ProtoMessage()               {}
func (*Call) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Call) GetModule() *singingcat.ModuleRef {
	if m != nil {
		return m.Module
	}
	return nil
}

func (m *Call) GetType() singingcat.ComType {
	if m != nil {
		return m.Type
	}
	return singingcat.ComType_UNDEFINED
}

func (m *Call) GetArgs() [][]byte {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Call) GetRetrySeconds() uint32 {
	if m != nil {
		return m.RetrySeconds
	}
	return 0
}

type CallResponse struct {
	Call         *Call                 `protobuf:"bytes,1,opt,name=Call" json:"Call,omitempty"`
	Success      bool                  `protobuf:"varint,2,opt,name=Success" json:"Success,omitempty"`
	ErrorMessage string                `protobuf:"bytes,3,opt,name=ErrorMessage" json:"ErrorMessage,omitempty"`
	Seq          uint32                `protobuf:"varint,4,opt,name=Seq" json:"Seq,omitempty"`
	Responses    []*singingcat.Command `protobuf:"bytes,5,rep,name=Responses" json:"Responses,omitempty"`
}

func (m *CallResponse) Reset()                    { *m = CallResponse{} }
func (m *CallResponse) String() string            { return proto.CompactTextString(m) }
func (*CallResponse) ProtoMessage()               {}
func (*CallResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CallResponse) GetCall() *Call {
	if m != nil {
		return m.Call
	}
	return nil
}

func (m *CallResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CallResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *CallResponse) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *CallResponse) GetResponses() []*singingcat.Command {
	if m != nil {
		return m.Responses
	}
	return nil
}

// a protobut, usually sent back to scmodcomms after processing a command
type ComResponse struct {
	SendReply bool `protobuf:"varint,1,opt,name=SendReply" json:"SendReply,omitempty"`
}

func (m *ComResponse) Reset()                    { *m = ComResponse{} }
func (m *ComResponse) String() string            { return proto.CompactTextString(m) }
func (*ComResponse) ProtoMessage()               {}
func (*ComResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ComResponse) GetSendReply() bool {
	if m != nil {
		return m.SendReply
	}
	return false
}

type SpecialRoute struct {
}

func (m *SpecialRoute) Reset()                    { *m = SpecialRoute{} }
func (m *SpecialRoute) String() string            { return proto.CompactTextString(m) }
func (*SpecialRoute) ProtoMessage()               {}
func (*SpecialRoute) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func init() {
	proto.RegisterType((*Response)(nil), "scmodcomms.Response")
	proto.RegisterType((*ProcessRequest)(nil), "scmodcomms.ProcessRequest")
	proto.RegisterType((*ProcessResponse)(nil), "scmodcomms.ProcessResponse")
	proto.RegisterType((*ModuleStats)(nil), "scmodcomms.ModuleStats")
	proto.RegisterType((*Flow)(nil), "scmodcomms.Flow")
	proto.RegisterType((*ModuleStatus)(nil), "scmodcomms.ModuleStatus")
	proto.RegisterType((*FlowID)(nil), "scmodcomms.FlowID")
	proto.RegisterType((*Call)(nil), "scmodcomms.Call")
	proto.RegisterType((*CallResponse)(nil), "scmodcomms.CallResponse")
	proto.RegisterType((*ComResponse)(nil), "scmodcomms.ComResponse")
	proto.RegisterType((*SpecialRoute)(nil), "scmodcomms.SpecialRoute")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SCModCommsService service

type SCModCommsServiceClient interface {
	// cancel flows for a module
	CancelFlow(ctx context.Context, in *FlowID, opts ...grpc.CallOption) (*common.Void, error)
	// get me the current status of a module, e.g. which flows are active)
	GetModuleStatus(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*ModuleStatus, error)
	// intented to be called by the scserver whenever it receives a new command
	ProcessCommand(ctx context.Context, in *ProcessRequest, opts ...grpc.CallOption) (*ProcessResponse, error)
	// enquire status of a module (async, this triggers a request to the module)
	Enquire(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error)
	// send a command to a module (convenience method around scserver to use moduleid instead of nodeid etc..)
	SendAsync(ctx context.Context, in *Call, opts ...grpc.CallOption) (*CallResponse, error)
	// send a command to a module (convenience method around scserver to use moduleid instead of nodeid etc..)
	SendSync(ctx context.Context, in *Call, opts ...grpc.CallOption) (*CallResponse, error)
	// get module stats for a given module
	GetModuleStats(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*ModuleStats, error)
}

type sCModCommsServiceClient struct {
	cc *grpc.ClientConn
}

func NewSCModCommsServiceClient(cc *grpc.ClientConn) SCModCommsServiceClient {
	return &sCModCommsServiceClient{cc}
}

func (c *sCModCommsServiceClient) CancelFlow(ctx context.Context, in *FlowID, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scmodcomms.SCModCommsService/CancelFlow", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCModCommsServiceClient) GetModuleStatus(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*ModuleStatus, error) {
	out := new(ModuleStatus)
	err := grpc.Invoke(ctx, "/scmodcomms.SCModCommsService/GetModuleStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCModCommsServiceClient) ProcessCommand(ctx context.Context, in *ProcessRequest, opts ...grpc.CallOption) (*ProcessResponse, error) {
	out := new(ProcessResponse)
	err := grpc.Invoke(ctx, "/scmodcomms.SCModCommsService/ProcessCommand", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCModCommsServiceClient) Enquire(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scmodcomms.SCModCommsService/Enquire", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCModCommsServiceClient) SendAsync(ctx context.Context, in *Call, opts ...grpc.CallOption) (*CallResponse, error) {
	out := new(CallResponse)
	err := grpc.Invoke(ctx, "/scmodcomms.SCModCommsService/SendAsync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCModCommsServiceClient) SendSync(ctx context.Context, in *Call, opts ...grpc.CallOption) (*CallResponse, error) {
	out := new(CallResponse)
	err := grpc.Invoke(ctx, "/scmodcomms.SCModCommsService/SendSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCModCommsServiceClient) GetModuleStats(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*ModuleStats, error) {
	out := new(ModuleStats)
	err := grpc.Invoke(ctx, "/scmodcomms.SCModCommsService/GetModuleStats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SCModCommsService service

type SCModCommsServiceServer interface {
	// cancel flows for a module
	CancelFlow(context.Context, *FlowID) (*common.Void, error)
	// get me the current status of a module, e.g. which flows are active)
	GetModuleStatus(context.Context, *singingcat.ModuleRef) (*ModuleStatus, error)
	// intented to be called by the scserver whenever it receives a new command
	ProcessCommand(context.Context, *ProcessRequest) (*ProcessResponse, error)
	// enquire status of a module (async, this triggers a request to the module)
	Enquire(context.Context, *singingcat.ModuleRef) (*common.Void, error)
	// send a command to a module (convenience method around scserver to use moduleid instead of nodeid etc..)
	SendAsync(context.Context, *Call) (*CallResponse, error)
	// send a command to a module (convenience method around scserver to use moduleid instead of nodeid etc..)
	SendSync(context.Context, *Call) (*CallResponse, error)
	// get module stats for a given module
	GetModuleStats(context.Context, *singingcat.ModuleRef) (*ModuleStats, error)
}

func RegisterSCModCommsServiceServer(s *grpc.Server, srv SCModCommsServiceServer) {
	s.RegisterService(&_SCModCommsService_serviceDesc, srv)
}

func _SCModCommsService_CancelFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCModCommsServiceServer).CancelFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scmodcomms.SCModCommsService/CancelFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCModCommsServiceServer).CancelFlow(ctx, req.(*FlowID))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCModCommsService_GetModuleStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCModCommsServiceServer).GetModuleStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scmodcomms.SCModCommsService/GetModuleStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCModCommsServiceServer).GetModuleStatus(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCModCommsService_ProcessCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCModCommsServiceServer).ProcessCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scmodcomms.SCModCommsService/ProcessCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCModCommsServiceServer).ProcessCommand(ctx, req.(*ProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCModCommsService_Enquire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCModCommsServiceServer).Enquire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scmodcomms.SCModCommsService/Enquire",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCModCommsServiceServer).Enquire(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCModCommsService_SendAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Call)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCModCommsServiceServer).SendAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scmodcomms.SCModCommsService/SendAsync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCModCommsServiceServer).SendAsync(ctx, req.(*Call))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCModCommsService_SendSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Call)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCModCommsServiceServer).SendSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scmodcomms.SCModCommsService/SendSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCModCommsServiceServer).SendSync(ctx, req.(*Call))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCModCommsService_GetModuleStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCModCommsServiceServer).GetModuleStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scmodcomms.SCModCommsService/GetModuleStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCModCommsServiceServer).GetModuleStats(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

var _SCModCommsService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scmodcomms.SCModCommsService",
	HandlerType: (*SCModCommsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CancelFlow",
			Handler:    _SCModCommsService_CancelFlow_Handler,
		},
		{
			MethodName: "GetModuleStatus",
			Handler:    _SCModCommsService_GetModuleStatus_Handler,
		},
		{
			MethodName: "ProcessCommand",
			Handler:    _SCModCommsService_ProcessCommand_Handler,
		},
		{
			MethodName: "Enquire",
			Handler:    _SCModCommsService_Enquire_Handler,
		},
		{
			MethodName: "SendAsync",
			Handler:    _SCModCommsService_SendAsync_Handler,
		},
		{
			MethodName: "SendSync",
			Handler:    _SCModCommsService_SendSync_Handler,
		},
		{
			MethodName: "GetModuleStats",
			Handler:    _SCModCommsService_GetModuleStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.singingcat.net/apis/scmodcomms/scmodcomms.proto",
}

func init() {
	proto.RegisterFile("golang.singingcat.net/apis/scmodcomms/scmodcomms.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 754 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x55, 0x6d, 0x6b, 0xeb, 0x36,
	0x14, 0x26, 0x2f, 0xcd, 0xcb, 0x69, 0x6e, 0x7a, 0xa7, 0x31, 0xae, 0xc9, 0x2e, 0x23, 0x98, 0xfb,
	0x12, 0xd8, 0xea, 0xb2, 0x0e, 0xba, 0xed, 0xd3, 0xd6, 0x26, 0x6d, 0x31, 0xac, 0xa5, 0xc8, 0x65,
	0x9f, 0xa7, 0xda, 0x67, 0xc1, 0x60, 0x4b, 0xa9, 0x24, 0xb7, 0xcb, 0x1f, 0xd9, 0x3f, 0x19, 0xfb,
	0x19, 0xfb, 0x4b, 0x43, 0xb2, 0x92, 0xd8, 0x69, 0x5a, 0xe8, 0x97, 0x44, 0x7e, 0xce, 0x73, 0x8e,
	0x1e, 0x3d, 0x47, 0x2f, 0x70, 0x32, 0x17, 0x19, 0xe3, 0xf3, 0x40, 0xa5, 0x7c, 0x9e, 0xf2, 0x79,
	0xcc, 0x74, 0xc0, 0x51, 0x1f, 0xb1, 0x45, 0xaa, 0x8e, 0x54, 0x9c, 0x8b, 0x24, 0x16, 0x79, 0x5e,
	0x1d, 0x06, 0x0b, 0x29, 0xb4, 0x20, 0xb0, 0x41, 0x46, 0x2f, 0xd6, 0x58, 0x63, 0x95, 0x61, 0x59,
	0x63, 0xf4, 0xdd, 0x8b, 0x73, 0x3f, 0xe2, 0x5d, 0xf9, 0xeb, 0xd8, 0x81, 0x63, 0xc7, 0x82, 0x4b,
	0x96, 0x3c, 0x0a, 0x91, 0x6c, 0xd8, 0x46, 0x87, 0xe0, 0xee, 0xaf, 0xe4, 0xfb, 0x7f, 0x40, 0x8f,
	0xa2, 0x5a, 0x08, 0xae, 0x90, 0x1c, 0x42, 0x77, 0x2a, 0xf2, 0x9c, 0xf1, 0xc4, 0x6b, 0x8c, 0x1b,
	0x93, 0xfd, 0xe3, 0x2f, 0xab, 0x93, 0xba, 0x10, 0x5d, 0x71, 0xc8, 0x47, 0xe8, 0x44, 0xc8, 0x13,
	0x94, 0x5e, 0xd3, 0xb2, 0xdf, 0x04, 0xa5, 0x90, 0x2b, 0x91, 0x14, 0x19, 0x52, 0x17, 0xf4, 0x7f,
	0x81, 0xe1, 0x8d, 0x14, 0x31, 0x2a, 0x45, 0xf1, 0xbe, 0x40, 0xa5, 0x5f, 0x39, 0x8f, 0xff, 0x33,
	0x1c, 0xac, 0x0b, 0x38, 0xa5, 0x9f, 0x60, 0x18, 0x69, 0xb1, 0x70, 0x70, 0xca, 0xe7, 0xb6, 0x50,
	0x8f, 0x6e, 0xa1, 0xfe, 0x25, 0xec, 0x97, 0x6a, 0x22, 0xcd, 0xb4, 0x22, 0x43, 0x68, 0x86, 0x33,
	0x4b, 0x6d, 0xd3, 0x66, 0x38, 0x23, 0x13, 0x38, 0xf8, 0x8d, 0x29, 0x3d, 0x15, 0x39, 0xc5, 0x18,
	0xd3, 0x07, 0x4c, 0xec, 0x52, 0xde, 0xd0, 0x6d, 0xd8, 0xff, 0xaf, 0x09, 0xed, 0x8b, 0x4c, 0x3c,
	0x92, 0x43, 0xe8, 0x94, 0x15, 0x9d, 0xf4, 0xaf, 0xaa, 0xd2, 0xdd, 0xca, 0xf1, 0x4f, 0xea, 0x48,
	0xe4, 0x1b, 0x80, 0x90, 0x6b, 0x94, 0x9c, 0x65, 0xe1, 0xcc, 0x15, 0xaf, 0x20, 0xc4, 0x83, 0xee,
	0x54, 0x22, 0xd3, 0x98, 0x78, 0x2d, 0x1b, 0x5c, 0x7d, 0x12, 0x1f, 0x06, 0xb7, 0x69, 0x8e, 0x51,
	0xca, 0x63, 0xbc, 0x11, 0xca, 0x6b, 0xdb, 0x70, 0x0d, 0x23, 0xef, 0xa1, 0x1f, 0xaa, 0x48, 0x33,
	0x69, 0xf2, 0xf7, 0xac, 0x03, 0x1b, 0x80, 0x10, 0x68, 0x5f, 0xb3, 0x1c, 0xbd, 0xce, 0xb8, 0x31,
	0xe9, 0x53, 0x3b, 0x36, 0x2b, 0x9e, 0x16, 0x52, 0x22, 0xd7, 0x37, 0x42, 0xa5, 0x3a, 0x15, 0xdc,
	0xeb, 0x96, 0x2b, 0xde, 0x82, 0xc9, 0x4f, 0xf0, 0x6e, 0x0b, 0xba, 0x60, 0x69, 0x56, 0x48, 0x54,
	0x5e, 0xcf, 0x66, 0x3c, 0x17, 0x26, 0x1f, 0xa0, 0x7d, 0x8d, 0x7f, 0x69, 0xaf, 0x6f, 0x0d, 0x7a,
	0x1b, 0x54, 0x4e, 0x85, 0xb1, 0x90, 0xda, 0xa8, 0x7f, 0x02, 0x83, 0x4d, 0x6b, 0x0a, 0x45, 0x3e,
	0xc1, 0x9e, 0x89, 0x2a, 0xaf, 0x31, 0x6e, 0xed, 0x4c, 0x2b, 0xc3, 0xfe, 0x04, 0x3a, 0x66, 0x10,
	0xce, 0xb6, 0xbc, 0x6d, 0x6c, 0x7b, 0xeb, 0xff, 0xdd, 0x80, 0xf6, 0x94, 0x65, 0xd9, 0x6b, 0x7b,
	0xf6, 0x19, 0xda, 0xb7, 0xcb, 0x05, 0xda, 0x6e, 0x0d, 0x9f, 0xec, 0x4d, 0x13, 0xa2, 0x96, 0x60,
	0x0c, 0x3e, 0x95, 0x73, 0xe5, 0xb5, 0xc6, 0xad, 0xc9, 0x80, 0xda, 0xb1, 0x69, 0x1b, 0x45, 0x2d,
	0x97, 0x11, 0xc6, 0x82, 0x27, 0xeb, 0xb6, 0x55, 0x31, 0xff, 0xdf, 0x06, 0x0c, 0x8c, 0xb0, 0xf5,
	0x76, 0xfe, 0x50, 0x0a, 0x75, 0xf2, 0x6a, 0x4b, 0xb7, 0xbc, 0x72, 0x19, 0x1e, 0x74, 0xa3, 0x22,
	0x36, 0x5b, 0xdb, 0x4a, 0xeb, 0xd1, 0xd5, 0xa7, 0x99, 0xf4, 0x5c, 0x4a, 0x21, 0xaf, 0x50, 0x29,
	0x36, 0x47, 0xbb, 0x95, 0xfa, 0xb4, 0x86, 0x91, 0xb7, 0xd0, 0x8a, 0xf0, 0xde, 0xe9, 0x31, 0x43,
	0xf2, 0x3d, 0xf4, 0x57, 0x0a, 0x94, 0xb7, 0x67, 0x5d, 0xdf, 0x79, 0x10, 0x37, 0x2c, 0xff, 0x5b,
	0xd8, 0xb7, 0xa7, 0xc2, 0xe9, 0x7e, 0x0f, 0x7d, 0x73, 0xc8, 0x29, 0x2e, 0xb2, 0xa5, 0x3b, 0x81,
	0x1b, 0xc0, 0x1f, 0xc2, 0x20, 0x5a, 0x60, 0x9c, 0xb2, 0x8c, 0x8a, 0x42, 0xe3, 0xf1, 0x3f, 0x2d,
	0xf8, 0x22, 0x9a, 0x5e, 0x89, 0xc4, 0x14, 0x56, 0x11, 0xca, 0x87, 0x34, 0x46, 0x12, 0x00, 0x4c,
	0x19, 0x8f, 0x31, 0xb3, 0xc7, 0x8b, 0x6c, 0xb7, 0x3d, 0x9c, 0x8d, 0x06, 0x81, 0xbb, 0xb1, 0x7e,
	0x17, 0x69, 0x42, 0xce, 0xe0, 0xe0, 0x12, 0x75, 0x6d, 0xeb, 0xec, 0xee, 0xe7, 0xc8, 0xab, 0xd6,
	0xaa, 0x25, 0x84, 0xeb, 0x2b, 0x69, 0x75, 0x97, 0x8d, 0xaa, 0xdc, 0xfa, 0x75, 0x35, 0xfa, 0x7a,
	0x67, 0xcc, 0x59, 0x10, 0x40, 0xf7, 0x9c, 0xdf, 0x17, 0xa9, 0xc4, 0xe7, 0x64, 0xd4, 0xe5, 0xff,
	0x58, 0x5a, 0x76, 0xaa, 0x96, 0x3c, 0x26, 0x4f, 0x3a, 0x5d, 0xd7, 0x5c, 0xdb, 0x23, 0x27, 0xd0,
	0x33, 0x89, 0xd1, 0x6b, 0xf3, 0x7e, 0x85, 0x61, 0xcd, 0xaf, 0x67, 0xed, 0x7a, 0xb7, 0xdb, 0x2e,
	0x75, 0xf6, 0x19, 0x3e, 0x72, 0xd4, 0xd5, 0x24, 0xf7, 0xc6, 0x98, 0x47, 0xa5, 0x92, 0x74, 0xd7,
	0xb1, 0x4f, 0xca, 0x0f, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0xb7, 0xa3, 0x0e, 0x9e, 0x2e, 0x07,
	0x00, 0x00,
}
